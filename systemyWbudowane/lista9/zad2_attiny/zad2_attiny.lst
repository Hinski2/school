
zad2_attiny.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000098  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00000098  0000010c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000012  00000000  00000000  0000010c  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000120  2**2
                  CONTENTS, READONLY, OCTETS
  4 .debug_aranges 00000028  00000000  00000000  0000015c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  5 .debug_info   00000607  00000000  00000000  00000184  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_abbrev 0000056f  00000000  00000000  0000078b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_line   000002fb  00000000  00000000  00000cfa  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_frame  00000044  00000000  00000000  00000ff8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_str    0000029b  00000000  00000000  0000103c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_line_str 0000008d  00000000  00000000  000012d7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_loclists 00000080  00000000  00000000  00001364  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_rnglists 00000040  00000000  00000000  000013e4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <__vectors>:
   0:	10 c0       	rjmp	.+32     	; 0x22 <__ctors_end>
   2:	17 c0       	rjmp	.+46     	; 0x32 <__bad_interrupt>
   4:	16 c0       	rjmp	.+44     	; 0x32 <__bad_interrupt>
   6:	15 c0       	rjmp	.+42     	; 0x32 <__bad_interrupt>
   8:	14 c0       	rjmp	.+40     	; 0x32 <__bad_interrupt>
   a:	13 c0       	rjmp	.+38     	; 0x32 <__bad_interrupt>
   c:	12 c0       	rjmp	.+36     	; 0x32 <__bad_interrupt>
   e:	11 c0       	rjmp	.+34     	; 0x32 <__bad_interrupt>
  10:	10 c0       	rjmp	.+32     	; 0x32 <__bad_interrupt>
  12:	0f c0       	rjmp	.+30     	; 0x32 <__bad_interrupt>
  14:	0e c0       	rjmp	.+28     	; 0x32 <__bad_interrupt>
  16:	0d c0       	rjmp	.+26     	; 0x32 <__bad_interrupt>
  18:	0c c0       	rjmp	.+24     	; 0x32 <__bad_interrupt>
  1a:	0b c0       	rjmp	.+22     	; 0x32 <__bad_interrupt>
  1c:	0a c0       	rjmp	.+20     	; 0x32 <__bad_interrupt>
  1e:	09 c0       	rjmp	.+18     	; 0x32 <__bad_interrupt>
  20:	08 c0       	rjmp	.+16     	; 0x32 <__bad_interrupt>

00000022 <__ctors_end>:
  22:	11 24       	eor	r1, r1
  24:	1f be       	out	0x3f, r1	; 63
  26:	cf e5       	ldi	r28, 0x5F	; 95
  28:	d2 e0       	ldi	r29, 0x02	; 2
  2a:	de bf       	out	0x3e, r29	; 62
  2c:	cd bf       	out	0x3d, r28	; 61
  2e:	16 d0       	rcall	.+44     	; 0x5c <main>
  30:	31 c0       	rjmp	.+98     	; 0x94 <_exit>

00000032 <__bad_interrupt>:
  32:	e6 cf       	rjmp	.-52     	; 0x0 <__vectors>

00000034 <init>:
#define SCK PA4
#define CS PA3


void init() {
    LED_DDR |= _BV(LED);  // output
  34:	ba 9a       	sbi	0x17, 2	; 23

00000036 <.Loc.3>:
    BTN_DDR &= ~_BV(BTN); // input
  36:	d7 98       	cbi	0x1a, 7	; 26

00000038 <.Loc.5>:
    BTN_PORT |= _BV(BTN); // pull up
  38:	df 9a       	sbi	0x1b, 7	; 27

0000003a <.Loc.7>:

    SPI_DDR |= _BV(MOSI) | _BV(SCK) | _BV(CS); // output
  3a:	8a b3       	in	r24, 0x1a	; 26

0000003c <.Loc.8>:
  3c:	88 63       	ori	r24, 0x38	; 56
  3e:	8a bb       	out	0x1a, r24	; 26

00000040 <.Loc.10>:
    SPI_PORT |= _BV(MISO); // pull up
  40:	de 9a       	sbi	0x1b, 6	; 27

00000042 <.Loc.11>:
    SPI_PORT |= _BV(CS);  // zaczynamy w stanei wysokim
  42:	db 9a       	sbi	0x1b, 3	; 27

00000044 <.Loc.13>:
}
  44:	08 95       	ret

00000046 <spi_transfer>:

uint8_t spi_transfer(uint8_t data) {
    // załaduj dane do przesłania
    USIDR = data;
  46:	8f b9       	out	0x0f, r24	; 15

00000048 <.Loc.17>:
    // wyczyść flagę przerwania USI
    USISR = _BV(USIOIF);
  48:	80 e4       	ldi	r24, 0x40	; 64

0000004a <.Loc.19>:
  4a:	8e b9       	out	0x0e, r24	; 14

0000004c <.Loc.20>:
    // póki transmisja nie została ukończona, wysyłaj impulsy zegara
    while (!(USISR & _BV(USIOIF))) {
  4c:	76 99       	sbic	0x0e, 6	; 14
  4e:	04 c0       	rjmp	.+8      	; 0x58 <.L4>

00000050 <.Loc.22>:
        // wygeneruj pojedyncze zbocze zegarowe
        // zostanie wykonane 16 razy
        USICR = _BV(USIWM0) | _BV(USICS1) | _BV(USICLK) | _BV(USITC);
  50:	8b e1       	ldi	r24, 0x1B	; 27

00000052 <.L5>:
  52:	8d b9       	out	0x0d, r24	; 13

00000054 <.Loc.25>:
    while (!(USISR & _BV(USIOIF))) {
  54:	76 9b       	sbis	0x0e, 6	; 14
  56:	fd cf       	rjmp	.-6      	; 0x52 <.L5>

00000058 <.L4>:
    }
    // zwróć otrzymane dane
    return USIDR;
  58:	8f b1       	in	r24, 0x0f	; 15

0000005a <.Loc.28>:

}
  5a:	08 95       	ret

0000005c <main>:
inline uint8_t handle_button() { // 1 wciśnięty
    return !(BTN_PIN & _BV(BTN));
}

int main() {
    init();    
  5c:	eb df       	rcall	.-42     	; 0x34 <init>

0000005e <.LBB12>:
    USISR = _BV(USIOIF);
  5e:	20 e4       	ldi	r18, 0x40	; 64

00000060 <.Loc.32>:
        USICR = _BV(USIWM0) | _BV(USICS1) | _BV(USICLK) | _BV(USITC);
  60:	8b e1       	ldi	r24, 0x1B	; 27

00000062 <.L13>:
    return !(BTN_PIN & _BV(BTN));
  62:	99 27       	eor	r25, r25
  64:	cf 9b       	sbis	0x19, 7	; 25
  66:	93 95       	inc	r25

00000068 <.LBE16>:

    for(;;) {
        uint8_t attiny_btn = handle_button();
        
        // start transmisji
        SPI_PORT &= ~_BV(CS);
  68:	db 98       	cbi	0x1b, 3	; 27

0000006a <.LBI13>:
    USIDR = data;
  6a:	9f b9       	out	0x0f, r25	; 15

0000006c <.Loc.45>:
    USISR = _BV(USIOIF);
  6c:	2e b9       	out	0x0e, r18	; 14

0000006e <.Loc.47>:
    while (!(USISR & _BV(USIOIF))) {
  6e:	76 99       	sbic	0x0e, 6	; 14
  70:	03 c0       	rjmp	.+6      	; 0x78 <.L9>

00000072 <.L10>:
        USICR = _BV(USIWM0) | _BV(USICS1) | _BV(USICLK) | _BV(USITC);
  72:	8d b9       	out	0x0d, r24	; 13

00000074 <.Loc.51>:
    while (!(USISR & _BV(USIOIF))) {
  74:	76 9b       	sbis	0x0e, 6	; 14
  76:	fd cf       	rjmp	.-6      	; 0x72 <.L10>

00000078 <.L9>:
    return USIDR;
  78:	9f b1       	in	r25, 0x0f	; 15

0000007a <.LVL6>:
        uint8_t atmega_btn = spi_transfer(attiny_btn);
        SPI_PORT |= _BV(CS);
  7a:	db 9a       	sbi	0x1b, 3	; 27

0000007c <.Loc.57>:

        if(atmega_btn == 1) LED_PORT |= _BV(LED);
  7c:	91 30       	cpi	r25, 0x01	; 1
  7e:	41 f0       	breq	.+16     	; 0x90 <.L16>

00000080 <.Loc.59>:
        else LED_PORT &= ~_BV(LED);
  80:	c2 98       	cbi	0x18, 2	; 24

00000082 <.L12>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(__builtin_ceil(__builtin_fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  82:	e3 ec       	ldi	r30, 0xC3	; 195
  84:	f9 e0       	ldi	r31, 0x09	; 9

00000086 <.L1^B1>:
  86:	31 97       	sbiw	r30, 0x01	; 1
  88:	f1 f7       	brne	.-4      	; 0x86 <.L1^B1>
  8a:	00 c0       	rjmp	.+0      	; 0x8c <L0^A>

0000008c <L0^A>:
	...

0000008e <.Loc.69>:
	}
	else
		__ticks = (uint16_t)__tmp;
	_delay_loop_2(__ticks);
#endif
}
  8e:	e9 cf       	rjmp	.-46     	; 0x62 <.L13>

00000090 <.L16>:
        if(atmega_btn == 1) LED_PORT |= _BV(LED);
  90:	c2 9a       	sbi	0x18, 2	; 24
  92:	f7 cf       	rjmp	.-18     	; 0x82 <.L12>

00000094 <_exit>:
  94:	f8 94       	cli

00000096 <__stop_program>:
  96:	ff cf       	rjmp	.-2      	; 0x96 <__stop_program>
